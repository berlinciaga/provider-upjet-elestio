// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type ServiceInitParameters struct {

	// Service admin email. Requires replace to change it.
	AdminEmail *string `json:"adminEmail,omitempty" tf:"admin_email,omitempty"`

	// Service alerts state. **Default** `true`.
	AlertsEnabled *bool `json:"alertsEnabled,omitempty" tf:"alerts_enabled,omitempty"`

	// Service app auto update state. **Default** `true`.
	AppAutoUpdatesEnabled *bool `json:"appAutoUpdatesEnabled,omitempty" tf:"app_auto_updates_enabled,omitempty"`

	// Service backups state.  Requires a support_level higher than `level1`. **Default** `false`.
	BackupsEnabled *bool `json:"backupsEnabled,omitempty" tf:"backups_enabled,omitempty"`

	// Indicate the list of domains for which you want to activate HTTPS / TLS / SSL. You will also need to create a DNS entry on your domain name (from your registrar control panel) pointing to your service. You must create a CNAME record pointing to the service `cname` value. Alternatively, you can create an A record pointing to the service `ipv4` value.
	// +listType=set
	CustomDomainNames []*string `json:"customDomainNames,omitempty" tf:"custom_domain_names,omitempty"`

	// The datacenter of the provider where the service will be hosted. You can look for available datacenters in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). Requires replace to change it.
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	// Set the default password used by you services at **CREATION** time.</br>The password can only contain alphanumeric characters or hyphens `-`. Require at least 10 characters, one uppercase letter, one lowercase letter and one number.</br>If you don't set a password, a random one will be generated by the API.</br>This attribute will **not be synced** after the creation. Use `admin.password` or `database_admin.password` to get the current password after the creation.
	DefaultPassword *string `json:"defaultPassword,omitempty" tf:"default_password,omitempty"`

	// Service firewall state. **Default** `false`.
	FirewallEnabled *bool `json:"firewallEnabled,omitempty" tf:"firewall_enabled,omitempty"`

	// Creates a backup and keeps all existing ones after deleting the service. If the project is deleted, the backups will be lost. **Default** `true`.
	KeepBackupsOnDeleteEnabled *bool `json:"keepBackupsOnDeleteEnabled,omitempty" tf:"keep_backups_on_delete_enabled,omitempty"`

	// Identifier of the project in which the service is. Requires replace to change it.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The name of the provider to use to host the service (must be lowercase). Common providers: `hetzner`, `do`, `lightsail`, `linode`, `vultr`, `scaleway`, `netcup`. You can look for available provider names in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). Requires replace to change it.
	ProviderName *string `json:"providerName,omitempty" tf:"provider_name,omitempty"`

	// Service remote backups state. **Default** `true`.
	RemoteBackupsEnabled *bool `json:"remoteBackupsEnabled,omitempty" tf:"remote_backups_enabled,omitempty"`

	// Service server name. Max length 60 characters, and can only include lowercase letters a-z, digits 0-9, and hyphens (-). Must be unique within the project. Requires replace to change it.
	ServerName *string `json:"serverName,omitempty" tf:"server_name,omitempty"`

	// The server type defines the power and memory allocated to the service. Each `provider_name` has a list of available server types. You can look for available server types in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). You can only upgrade it, not downgrade.<br/>Requires replace to update the server type with the provider `scale_way`.
	ServerType *string `json:"serverType,omitempty" tf:"server_type,omitempty"`

	// Service support level. Available support levels are `level1`, `level2` and `level3`. You can look for their advantages in the [pricing documentation](https://elest.io/pricing). It is recommended to use the web dashboard to change it without replacing the service.
	SupportLevel *string `json:"supportLevel,omitempty" tf:"support_level,omitempty"`

	// Service system auto update state. **Default** `true`.
	SystemAutoUpdatesEnabled *bool `json:"systemAutoUpdatesEnabled,omitempty" tf:"system_auto_updates_enabled,omitempty"`

	// Service system auto update security patches only state. **Default** `false`.
	SystemAutoUpdatesSecurityPatchesOnlyEnabled *bool `json:"systemAutoUpdatesSecurityPatchesOnlyEnabled,omitempty" tf:"system_auto_updates_security_patches_only_enabled,omitempty"`

	// The template identifier defines the software used. You can look for available template ids in the [templates documentation](https://elest.io/fully-managed-services).
	TemplateID *float64 `json:"templateId,omitempty" tf:"template_id,omitempty"`

	// This is the version of the software used as service.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ServiceObservation struct {

	// Service admin email. Requires replace to change it.
	AdminEmail *string `json:"adminEmail,omitempty" tf:"admin_email,omitempty"`

	// Service admin user.
	AdminUser *string `json:"adminUser,omitempty" tf:"admin_user,omitempty"`

	// Service alerts state. **Default** `true`.
	AlertsEnabled *bool `json:"alertsEnabled,omitempty" tf:"alerts_enabled,omitempty"`

	// Service app auto update day of week. `0 = Sunday`, `1 = Monday`, ..., `6 = Saturday`, `-1 = Everyday`
	AppAutoUpdatesDayOfWeek *float64 `json:"appAutoUpdatesDayOfWeek,omitempty" tf:"app_auto_updates_day_of_week,omitempty"`

	// Service app auto update state. **Default** `true`.
	AppAutoUpdatesEnabled *bool `json:"appAutoUpdatesEnabled,omitempty" tf:"app_auto_updates_enabled,omitempty"`

	// Service app auto update hour.
	AppAutoUpdatesHour *float64 `json:"appAutoUpdatesHour,omitempty" tf:"app_auto_updates_hour,omitempty"`

	// Service app auto update minute.
	AppAutoUpdatesMinute *float64 `json:"appAutoUpdatesMinute,omitempty" tf:"app_auto_updates_minute,omitempty"`

	// Service backups state.  Requires a support_level higher than `level1`. **Default** `false`.
	BackupsEnabled *bool `json:"backupsEnabled,omitempty" tf:"backups_enabled,omitempty"`

	// Service category.
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// Service city.
	City *string `json:"city,omitempty" tf:"city,omitempty"`

	// Service CNAME.
	Cname *string `json:"cname,omitempty" tf:"cname,omitempty"`

	// Service cores.
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// Service country.
	Country *string `json:"country,omitempty" tf:"country,omitempty"`

	// Service creation date.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// Service creator name.
	CreatorName *string `json:"creatorName,omitempty" tf:"creator_name,omitempty"`

	// Indicate the list of domains for which you want to activate HTTPS / TLS / SSL. You will also need to create a DNS entry on your domain name (from your registrar control panel) pointing to your service. You must create a CNAME record pointing to the service `cname` value. Alternatively, you can create an A record pointing to the service `ipv4` value.
	// +listType=set
	CustomDomainNames []*string `json:"customDomainNames,omitempty" tf:"custom_domain_names,omitempty"`

	// The datacenter of the provider where the service will be hosted. You can look for available datacenters in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). Requires replace to change it.
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	// Set the default password used by you services at **CREATION** time.</br>The password can only contain alphanumeric characters or hyphens `-`. Require at least 10 characters, one uppercase letter, one lowercase letter and one number.</br>If you don't set a password, a random one will be generated by the API.</br>This attribute will **not be synced** after the creation. Use `admin.password` or `database_admin.password` to get the current password after the creation.
	DefaultPassword *string `json:"defaultPassword,omitempty" tf:"default_password,omitempty"`

	// Service deployment endedAt date.
	DeploymentEndedAt *string `json:"deploymentEndedAt,omitempty" tf:"deployment_ended_at,omitempty"`

	// Service deployment startedAt date.
	DeploymentStartedAt *string `json:"deploymentStartedAt,omitempty" tf:"deployment_started_at,omitempty"`

	// Service deployement status.
	DeploymentStatus *string `json:"deploymentStatus,omitempty" tf:"deployment_status,omitempty"`

	// Service identifier unique and handled by Elestio.
	ElestioID *float64 `json:"elestioId,omitempty" tf:"elestio_id,omitempty"`

	// Service external backups state. **Default** `false`.
	ExternalBackupsEnabled *bool `json:"externalBackupsEnabled,omitempty" tf:"external_backups_enabled,omitempty"`

	// Service external backups retain day of week. `0 = Sunday`, `1 = Monday`, ..., `6 = Saturday`, `-1 = Everyday`
	ExternalBackupsRetainDayOfWeek *float64 `json:"externalBackupsRetainDayOfWeek,omitempty" tf:"external_backups_retain_day_of_week,omitempty"`

	// Service external backups update day. `0 = Sunday`, `1 = Monday`, ..., `6 = Saturday`, `-1 = Everyday`
	ExternalBackupsUpdateDayOfWeek *float64 `json:"externalBackupsUpdateDayOfWeek,omitempty" tf:"external_backups_update_day_of_week,omitempty"`

	// Service external backups update hour.
	ExternalBackupsUpdateHour *float64 `json:"externalBackupsUpdateHour,omitempty" tf:"external_backups_update_hour,omitempty"`

	// Service external backups update minute.
	ExternalBackupsUpdateMinute *float64 `json:"externalBackupsUpdateMinute,omitempty" tf:"external_backups_update_minute,omitempty"`

	// Service external backups update type.
	ExternalBackupsUpdateType *string `json:"externalBackupsUpdateType,omitempty" tf:"external_backups_update_type,omitempty"`

	// Service firewall state. **Default** `false`.
	FirewallEnabled *bool `json:"firewallEnabled,omitempty" tf:"firewall_enabled,omitempty"`

	// Service firewall id.
	FirewallID *string `json:"firewallId,omitempty" tf:"firewall_id,omitempty"`

	// Service firewall ports.
	FirewallPorts *string `json:"firewallPorts,omitempty" tf:"firewall_ports,omitempty"`

	// Service global IP.
	GlobalIP *string `json:"globalIp,omitempty" tf:"global_ip,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Service IPv4.
	IPv4 *string `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// Service IPv6.
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// Creates a backup and keeps all existing ones after deleting the service. If the project is deleted, the backups will be lost. **Default** `true`.
	KeepBackupsOnDeleteEnabled *bool `json:"keepBackupsOnDeleteEnabled,omitempty" tf:"keep_backups_on_delete_enabled,omitempty"`

	LastUpdated *string `json:"lastUpdated,omitempty" tf:"last_updated,omitempty"`

	// Service price per hour.
	PricePerHour *string `json:"pricePerHour,omitempty" tf:"price_per_hour,omitempty"`

	// Identifier of the project in which the service is. Requires replace to change it.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The name of the provider to use to host the service (must be lowercase). Common providers: `hetzner`, `do`, `lightsail`, `linode`, `vultr`, `scaleway`, `netcup`. You can look for available provider names in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). Requires replace to change it.
	ProviderName *string `json:"providerName,omitempty" tf:"provider_name,omitempty"`

	// Service ram size in GB.
	RAMSizeGb *string `json:"ramSizeGb,omitempty" tf:"ram_size_gb,omitempty"`

	// Service remote backups state. **Default** `true`.
	RemoteBackupsEnabled *bool `json:"remoteBackupsEnabled,omitempty" tf:"remote_backups_enabled,omitempty"`

	// Service root app path.
	RootAppPath *string `json:"rootAppPath,omitempty" tf:"root_app_path,omitempty"`

	// Service server name. Max length 60 characters, and can only include lowercase letters a-z, digits 0-9, and hyphens (-). Must be unique within the project. Requires replace to change it.
	ServerName *string `json:"serverName,omitempty" tf:"server_name,omitempty"`

	// The server type defines the power and memory allocated to the service. Each `provider_name` has a list of available server types. You can look for available server types in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). You can only upgrade it, not downgrade.<br/>Requires replace to update the server type with the provider `scale_way`.
	ServerType *string `json:"serverType,omitempty" tf:"server_type,omitempty"`

	// Service status.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Service storage size in GB.
	StorageSizeGb *float64 `json:"storageSizeGb,omitempty" tf:"storage_size_gb,omitempty"`

	// Service support level. Available support levels are `level1`, `level2` and `level3`. You can look for their advantages in the [pricing documentation](https://elest.io/pricing). It is recommended to use the web dashboard to change it without replacing the service.
	SupportLevel *string `json:"supportLevel,omitempty" tf:"support_level,omitempty"`

	// Service system auto update state. **Default** `true`.
	SystemAutoUpdatesEnabled *bool `json:"systemAutoUpdatesEnabled,omitempty" tf:"system_auto_updates_enabled,omitempty"`

	// Service system auto update reboot day of week. `0 = Sunday`, `1 = Monday`, ..., `6 = Saturday`, `-1 = Everyday`
	SystemAutoUpdatesRebootDayOfWeek *float64 `json:"systemAutoUpdatesRebootDayOfWeek,omitempty" tf:"system_auto_updates_reboot_day_of_week,omitempty"`

	// Service system auto update reboot hour.
	SystemAutoUpdatesRebootHour *float64 `json:"systemAutoUpdatesRebootHour,omitempty" tf:"system_auto_updates_reboot_hour,omitempty"`

	// Service system auto update reboot minute.
	SystemAutoUpdatesRebootMinute *float64 `json:"systemAutoUpdatesRebootMinute,omitempty" tf:"system_auto_updates_reboot_minute,omitempty"`

	// Service system auto update security patches only state. **Default** `false`.
	SystemAutoUpdatesSecurityPatchesOnlyEnabled *bool `json:"systemAutoUpdatesSecurityPatchesOnlyEnabled,omitempty" tf:"system_auto_updates_security_patches_only_enabled,omitempty"`

	// The template identifier defines the software used. You can look for available template ids in the [templates documentation](https://elest.io/fully-managed-services).
	TemplateID *float64 `json:"templateId,omitempty" tf:"template_id,omitempty"`

	// Service traffic included.
	TrafficIncluded *float64 `json:"trafficIncluded,omitempty" tf:"traffic_included,omitempty"`

	// Service traffic incoming.
	TrafficIncoming *float64 `json:"trafficIncoming,omitempty" tf:"traffic_incoming,omitempty"`

	// Service traffic outgoing.
	TrafficOutgoing *float64 `json:"trafficOutgoing,omitempty" tf:"traffic_outgoing,omitempty"`

	// This is the version of the software used as service.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type ServiceParameters struct {

	// Service admin email. Requires replace to change it.
	// +kubebuilder:validation:Optional
	AdminEmail *string `json:"adminEmail,omitempty" tf:"admin_email,omitempty"`

	// Service alerts state. **Default** `true`.
	// +kubebuilder:validation:Optional
	AlertsEnabled *bool `json:"alertsEnabled,omitempty" tf:"alerts_enabled,omitempty"`

	// Service app auto update state. **Default** `true`.
	// +kubebuilder:validation:Optional
	AppAutoUpdatesEnabled *bool `json:"appAutoUpdatesEnabled,omitempty" tf:"app_auto_updates_enabled,omitempty"`

	// Service backups state.  Requires a support_level higher than `level1`. **Default** `false`.
	// +kubebuilder:validation:Optional
	BackupsEnabled *bool `json:"backupsEnabled,omitempty" tf:"backups_enabled,omitempty"`

	// Indicate the list of domains for which you want to activate HTTPS / TLS / SSL. You will also need to create a DNS entry on your domain name (from your registrar control panel) pointing to your service. You must create a CNAME record pointing to the service `cname` value. Alternatively, you can create an A record pointing to the service `ipv4` value.
	// +kubebuilder:validation:Optional
	// +listType=set
	CustomDomainNames []*string `json:"customDomainNames,omitempty" tf:"custom_domain_names,omitempty"`

	// The datacenter of the provider where the service will be hosted. You can look for available datacenters in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). Requires replace to change it.
	// +kubebuilder:validation:Optional
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter,omitempty"`

	// Set the default password used by you services at **CREATION** time.</br>The password can only contain alphanumeric characters or hyphens `-`. Require at least 10 characters, one uppercase letter, one lowercase letter and one number.</br>If you don't set a password, a random one will be generated by the API.</br>This attribute will **not be synced** after the creation. Use `admin.password` or `database_admin.password` to get the current password after the creation.
	// +kubebuilder:validation:Optional
	DefaultPassword *string `json:"defaultPassword,omitempty" tf:"default_password,omitempty"`

	// Service firewall state. **Default** `false`.
	// +kubebuilder:validation:Optional
	FirewallEnabled *bool `json:"firewallEnabled,omitempty" tf:"firewall_enabled,omitempty"`

	// Creates a backup and keeps all existing ones after deleting the service. If the project is deleted, the backups will be lost. **Default** `true`.
	// +kubebuilder:validation:Optional
	KeepBackupsOnDeleteEnabled *bool `json:"keepBackupsOnDeleteEnabled,omitempty" tf:"keep_backups_on_delete_enabled,omitempty"`

	// Identifier of the project in which the service is. Requires replace to change it.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The name of the provider to use to host the service (must be lowercase). Common providers: `hetzner`, `do`, `lightsail`, `linode`, `vultr`, `scaleway`, `netcup`. You can look for available provider names in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). Requires replace to change it.
	// +kubebuilder:validation:Optional
	ProviderName *string `json:"providerName,omitempty" tf:"provider_name,omitempty"`

	// Service remote backups state. **Default** `true`.
	// +kubebuilder:validation:Optional
	RemoteBackupsEnabled *bool `json:"remoteBackupsEnabled,omitempty" tf:"remote_backups_enabled,omitempty"`

	// Service server name. Max length 60 characters, and can only include lowercase letters a-z, digits 0-9, and hyphens (-). Must be unique within the project. Requires replace to change it.
	// +kubebuilder:validation:Optional
	ServerName *string `json:"serverName,omitempty" tf:"server_name,omitempty"`

	// The server type defines the power and memory allocated to the service. Each `provider_name` has a list of available server types. You can look for available server types in the [providers documentation](https://registry.io/providers/elestio/elestio/latest/docs/guides/providers_datacenters_server_types). You can only upgrade it, not downgrade.<br/>Requires replace to update the server type with the provider `scale_way`.
	// +kubebuilder:validation:Optional
	ServerType *string `json:"serverType,omitempty" tf:"server_type,omitempty"`

	// Service support level. Available support levels are `level1`, `level2` and `level3`. You can look for their advantages in the [pricing documentation](https://elest.io/pricing). It is recommended to use the web dashboard to change it without replacing the service.
	// +kubebuilder:validation:Optional
	SupportLevel *string `json:"supportLevel,omitempty" tf:"support_level,omitempty"`

	// Service system auto update state. **Default** `true`.
	// +kubebuilder:validation:Optional
	SystemAutoUpdatesEnabled *bool `json:"systemAutoUpdatesEnabled,omitempty" tf:"system_auto_updates_enabled,omitempty"`

	// Service system auto update security patches only state. **Default** `false`.
	// +kubebuilder:validation:Optional
	SystemAutoUpdatesSecurityPatchesOnlyEnabled *bool `json:"systemAutoUpdatesSecurityPatchesOnlyEnabled,omitempty" tf:"system_auto_updates_security_patches_only_enabled,omitempty"`

	// The template identifier defines the software used. You can look for available template ids in the [templates documentation](https://elest.io/fully-managed-services).
	// +kubebuilder:validation:Optional
	TemplateID *float64 `json:"templateId,omitempty" tf:"template_id,omitempty"`

	// This is the version of the software used as service.
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

// ServiceSpec defines the desired state of Service
type ServiceSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            ServiceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ServiceInitParameters `json:"initProvider,omitempty"`
}

// ServiceStatus defines the observed state of Service.
type ServiceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Service is the Schema for the Services API. Elestio Service resource
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,}
type Service struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.datacenter) || (has(self.initProvider) && has(self.initProvider.datacenter))",message="spec.forProvider.datacenter is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.projectId) || (has(self.initProvider) && has(self.initProvider.projectId))",message="spec.forProvider.projectId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.providerName) || (has(self.initProvider) && has(self.initProvider.providerName))",message="spec.forProvider.providerName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.serverType) || (has(self.initProvider) && has(self.initProvider.serverType))",message="spec.forProvider.serverType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.templateId) || (has(self.initProvider) && has(self.initProvider.templateId))",message="spec.forProvider.templateId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.version) || (has(self.initProvider) && has(self.initProvider.version))",message="spec.forProvider.version is a required parameter"
	Spec   ServiceSpec   `json:"spec"`
	Status ServiceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceList contains a list of Services
type ServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Service `json:"items"`
}

// Repository type metadata.
var (
	Service_Kind             = "Service"
	Service_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Service_Kind}.String()
	Service_KindAPIVersion   = Service_Kind + "." + CRDGroupVersion.String()
	Service_GroupVersionKind = CRDGroupVersion.WithKind(Service_Kind)
)

func init() {
	SchemeBuilder.Register(&Service{}, &ServiceList{})
}
